# *子类 拥有 父类 的所有 方法 和 属性
# *子类 继承自 父类，可以直接 享受 父类中已经封装好的方法，不需要再次开发
# *当 父类 的方法实现不能满足子类需求时，可以对方法进行 重写(override)

# 覆盖
# *如果在开发中，父类的方法实现 和 子类的方法实现，完全不同
# *就可以使用 覆盖 的方式，在子类中 重新编写 父类的方法实现
# >具体的实现方式，就相当于在 子类中 定义了一个 和父类同名的方法并且实现
# 重写之后，在运行时，只会调用 子类中重写的方法，而不再会调用 父类封装的方法

# 拓展
# *如果在开发中，子类的方法实现 中 包含 父类的方法实现
#   *父类原本封装的方法实现 是 子类方法的一部分
# *就可以使用 扩展 的方式
#   1.在子类中 重写 父类的方法
#   2.在需要的位置使用 super().父类方法 来调用父类方法的执行
#   3.代码其他的位置针对子类的需求，编写 子类特有的代码实现

# 关于 super
# *在 Python 中 super 是一个 特殊的类
# * super() 就是使用 super 类创建出来的对象
# *最常 使用的场景就是在 重写父类方法时，调用 在父类中封装的方法实现

# 调用父类方法的另外一种方式
# 父类名.方法(self)
# *这种方法 不推荐使用，因为一旦 父类发生变化，方法调用位置的 类名 同样需要修改
# *在开发时，父类名 和 super() 两种方式不要混用
# *如果使用 当前子类名 调用方法，会形成递归调用，出现死循环

class Dog () :
    def eat (self) :
        print ("Eat")
    def drink (self) :
        print ("Drink")
    def run (self) :
        print ("Run")
    def sleep (self) :
        print ("Sleep")
    def bark (self) :
        print ("Wangwangwang!!!")


class Xiao (Dog) :
    def fly (self) :
        print ("I can fly.")
    def bark (self) :  # 重写方法
        # 针对子类特有的需求，编写代码
        print ("Wangwangwang likes a god.")
        # 使用 super(). 调用原本父类中封装的方法
        super ().bark ()
        # 使用 父类名.方法(self)
        Dog.bark (self)
        # 增加其他子类代码 
        print ("@#$%^@^@#$%@$%")

        # 注意，如果使用子类调用方法，会形成递归调用，出现死循环，报错
        # Xiao.bark ()

xiaotian = Xiao ()

xiaotian.bark ()